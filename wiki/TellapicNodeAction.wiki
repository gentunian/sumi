#summary Minimal explanation about SUMI
#labels Featured
<wiki:toc max_depth="2" />

= What role `TellapicNodeAction` objects should play? =

`TellapicNodeAction` is an interface that defines a couple of methods that some object should implement in order to follow an expected behaviour, but anyone can implement that interface as they want.

For the whole project perspective, an abstract class called `DefaultAbstractTellapicNodeAction` implements the mentioned interface and defines the _expected behaviour_ stated above.

So, what we should expect from concretes `DefaultAbstractTellapicNodeAction` objects?

Basically, this objects have:
  * A reference to a Swing `AbstractAction` object (_it could be_ `null`),
  * A key that indicates what kind of renderer it will use (_more on this later_),
  * A key that indicates what kind of editor it will use (_more on this later_),
  * A reference to a `TellapicNode` that is the node from the tree hierarchical column that contains an user object (_see_ `AbstractMutableTreeTableNode`),
  * An `Object` that represents the cell value,
  * A name,
  * And a boolean value indicating if the cell that we are representing is editable.

You may note that `DefaultAbstractTellapicNodeAction` provides information and placeholders to know enough on how to interact/represent/modify the data in a custom column for a specific node. Each _node action_ is information that a specific node provides with the ability to interact and modify that information. So, you _attach_ `DefaultAbstractTellapicNodeAction` objects to `TellapicNode`s. These objects are shown in cells and they are placed along columns and rows in the treetable. To be exact, none of these objects are _actually shown_ or rendered. These objects provides the mechanism to show, modify, and interact with the model data. They preserve a relationship with the nodes from the tree model in the sense that they represent some action on the node (or user object); some information from the node; etc.

The basic use of these _actions_ is as follows:

  * If desired, create a concrete class from `AbstractAction` to do something (`ActionEvent.getSource()` _will return a_ `DefaultAbstractTellapicNodeAction` _object if you've extended the behaviour-desired class_).

  * Extend `DefaultAbstractTellapicNodeAction` if none of the default classes (`DefaultTellapicNodeActionButton` ,`DefaultTellapicNodeActionCheckBox`,`DefaultTellapicNodeActionColor`,  `DefaultTellapicNodeActionCombo`,  `DefaultTellapicNodeActionLabel`) suits your needs. Take note that interaction with the model is made by the abstract class. You could override as needed or create your custom implementation directly from `TellapicNodeAction`, but you will miss most of the trick.

  * Create the renderer if needed. Renderers should implement `TellapicTableCellRenderer` (_I'll remove that constraint in a near future. The fact is that the interface extends_ `TableCellRenderer` _and provides_ `configureRenderer()` _method called inside_ `TellapicTreeTable` _with the correct action node_).

 * Create the editor if we need to interact with the information provided by the model. It's recommended to extend `AbstractTellapicCellEditor` as that abstract class overrides `stopCellEditing()` from `AbstractCellEditor` to perform the `AbstractAction` and execute the action over the node.

  * Register renderers and editors with the `TellapicTreeTable` object calling `registerRendererComponent()` and `registerEditorComponent()` respectively.

Everything should be set up if you've followed the above instructions. The last thing to do is to add user objects to nodes, add actions to nodes, add nodes to the model, etc.


== Minimal Example ==

What follows is an example to get you in the main idea. It should be noted that some portions of code should be avoided, cleaned and/or redesigned. For simplicity, and in order to answer [http://stackoverflow.com/questions/8923089/swing-jtable-custom-rendering/9375212 @gumuru question] I've made this custom example shorter and directly to the design idea:

=== Point 1: Create an `AbstractAction` object ===

{{{
package ar.com.tellapic.sumi.test;

import java.awt.event.ActionEvent;

/**
 *   Copyright (c) 2010 Sebastián Treu.
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; version 2 of the License.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 * @author
 *         Sebastian Treu 
 *         sebastian.treu(at)gmail.com
 *
 */
public class SomeSwingAction extends AbstractAction {
    private static final long serialVersionUID = 1L;

    public SomeSwingAction() {
        putValue(AbstractAction.NAME, "SomeSwingAction");
    }
    
    /* (non-Javadoc)
     * @see java.awt.event.ActionListener#actionPerformed(java.awt.event.ActionEvent)
     */
    @Override
    public void actionPerformed(ActionEvent e) {
        TellapicNodeAction action = (TellapicNodeAction) e.getSource();
        TellapicNode node = action.getNode();
        JOptionPane.showMessageDialog(null, "ActionPerformed for node: "+node);
    }
}
}}}

=== Point 2: Extend `DefaultAbstractTellapicNodeAction` ===

Take note that keys are hardcoded for simplicity

{{{
package ar.com.tellapic.sumi.test;

import javax.swing.AbstractAction;

import ar.com.tellapic.sumi.treetable.DefaultAbstractTellapicNodeAction;

/**
 *   Copyright (c) 2010 Sebastián Treu.
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; version 2 of the License.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 * @author
 *         Sebastian Treu 
 *         sebastian.treu(at)gmail.com
 *
 */
public class DualImageNodeAction extends DefaultAbstractTellapicNodeAction {

    /**
     * @param action The action that will be triggered.
     */
    public DualImageNodeAction(AbstractAction action) {
        super(action, "TickButtonEditor", "DualImageRenderer", true);
    }

    /* (non-Javadoc)
     * @see ar.com.tellapic.sumi.treetable.TellapicNodeAction#getData()
     */
    @Override
    public Object getData() {
        return new String[] {"/icons/Warning.png", "/icons/ok.png"};
    }
}
}}}

=== Point 3: Create the renderer ===

{{{
package ar.com.tellapic.sumi.test;

import java.awt.BorderLayout;

/**
 *   Copyright (c) 2010 Sebastián Treu.
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; version 2 of the License.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 * @author
 *         Sebastian Treu 
 *         sebastian.treu(at)gmail.com
 *
 */
public class DualImageRenderer extends TellapicAbstractPanelRenderer {
    private JLabel labelImage;
    private JButton buttonImage;

    public DualImageRenderer(boolean vertical) {
        super();

        labelImage = new JLabel();
        buttonImage = new JButton();
        labelImage.setHorizontalAlignment(JLabel.HORIZONTAL);
        labelImage.setVerticalAlignment(JLabel.CENTER);
        buttonImage.setHorizontalAlignment(JLabel.HORIZONTAL);
        buttonImage.setVerticalAlignment(JLabel.CENTER);
        if (!vertical) {
            setLayout(new GridLayout(0, 2));
            add(labelImage, BorderLayout.EAST);
            add(buttonImage, BorderLayout.WEST);
        } else { 
            setLayout(new GridLayout(2, 0));
            add(labelImage, BorderLayout.NORTH);
            add(buttonImage, BorderLayout.SOUTH);
        }
    }
    /* (non-Javadoc)
     * @see ar.com.tellapic.sumi.treetable.renderer.TellapicTableCellRenderer#configureRenderer(ar.com.tellapic.sumi.treetable.TellapicNodeAction, javax.swing.JTable, boolean)
     */
    @Override
    public void configureRenderer(TellapicNodeAction action, JTable table, boolean isSelected) {
        String[] data = (String[])action.getData();
        labelImage.setIcon(new ImageIcon(DualImageRenderer.class.getResource(data[0])));
        buttonImage.setIcon(new ImageIcon(DualImageRenderer.class.getResource(data[1])));
    }
    
    public JButton getButtonImage() {
        return buttonImage;
    }
    
    public JLabel getLabelImage() {
        return labelImage;
    }
}
}}}

=== Point 4: Create the editor ===

The following class need to get more work on it and defines a _button default editor_ in the package. Is almost written for this example only.

{{{
public class DefaultTellapicButtonEditor extends AbstractTellapicCellEditor implements TableCellEditor {

    private static final long serialVersionUID = 1L;

    protected JButton editor;
    
    public DefaultTellapicButtonEditor() {
        editor = new JButton();
        editor.setOpaque(true);
        editor.addActionListener(new ActionListener(){
            @Override
            public void actionPerformed(ActionEvent e) {
                stopCellEditing();
            }
        });
    }
    
    /* (non-Javadoc)
     * @see javax.swing.CellEditor#getCellEditorValue()
     */
    @Override
    public Object getCellEditorValue() {
        return "Testing";
    }

    /* (non-Javadoc)
     * @see javax.swing.table.TableCellEditor#getTableCellEditorComponent(javax.swing.JTable, java.lang.Object, boolean, int, int)
     */
    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        return editor;
    }
}
}}}

I don't encourage the use of these classes! I serialize and deserialize the used renderer because I know what I'm doing here. It's a `DualImageRenderer` so I copy the objects as they can be de/serialized and I take advantage of it for avoid copying each property.

{{{
public class TickButtonEditor extends DefaultTellapicButtonEditor implements TableCellEditor {
    private static final long serialVersionUID = 1L;
    
    public TickButtonEditor() {
        super();
    }
   
    /* (non-Javadoc)
     * @see javax.swing.table.TableCellEditor#getTableCellEditorComponent(javax.swing.JTable, java.lang.Object, boolean, int, int)
     */
    @Override
    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
        TableCellRenderer renderer = table.getCellRenderer(row, column);
        DualImageRenderer dualImageRenderer = (DualImageRenderer) renderer.getTableCellRendererComponent(table, value, isSelected, true, row, column);
        DualImageRenderer clonedRenderer = (DualImageRenderer) clonePanel(dualImageRenderer);
        JButton rendererButton = clonedRenderer.getButtonImage();
        clonedRenderer.remove(rendererButton);
        editor.setIcon(rendererButton.getIcon());
        clonedRenderer.add(editor);
        if (isSelected) {
            clonedRenderer.setBackground(table.getSelectionBackground());
            clonedRenderer.setForeground(table.getSelectionForeground());
        } else {
            clonedRenderer.setBackground(table.getBackground());
            clonedRenderer.setForeground(table.getForeground());
        }
        return clonedRenderer;
    }
    
    /**
     * 
     * @param toClone
     * @return
     */
    private JComponent clonePanel(JComponent toClone) {
        JComponent c = null;
        FileOutputStream fos;
        ObjectOutputStream oos = null;
        try {
            fos = new FileOutputStream("myObject.ser");
            oos = new ObjectOutputStream(fos);
            oos.writeObject(toClone);
            oos.flush();
            oos.close();
            // Deserialize the object persisted in "myObject.ser"
            FileInputStream fis = new FileInputStream("myObject.ser");
            ObjectInputStream ois = new ObjectInputStream(fis);
            c = (JComponent) ois.readObject();
            ois.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        return c;
    }

    /* (non-Javadoc)
     * @see javax.swing.CellEditor#getCellEditorValue()
     */
    @Override
    public Object getCellEditorValue() {
        return "SomethingUseful";
    }
}
}}}

=== Point 5: Register renderers and editors ===

{{{
...
tree.registerRendererComponent("DualImageRenderer", new DualImageRenderer(true));
tree.registerEditorComponent("TickButtonEditor", new TickButtonEditor());
...
// somewhere when you add nodes and set actions...
String str = "Hello World!";
TellapicNodeAction nodeAction = new DualImageNodeAction(new SomeSwingAction());
TellapicNode node = new TellapicNode(str, null); //null = no Icon.
node.addAction(nodeAction);
model.insertNodeInto(node, insertNodeAt, insertAtNode.getChildCount());
...
}}}

=== The results with a more elaborated example ===

[http://i.imgur.com/QkmGu.png This is how it should look in a complete example.]

http://i.imgur.com/QkmGu.png

However, this example is not complete for a self-running test. You could check/browse the code inside the `test` package.
<g:plusone size="medium"></g:plusone>

== Complex Example (Linux System User) ==

I created this `TellapicTreeTable` thing in order to extend the use of the SWING `JTable` (In fact, I extended [http://download.java.net/javadesktop/swinglabs/releases/0.8/docs/api/org/jdesktop/swingx/JXTreeTable.html `JXTreeTable`]). The needs were interfacing a treetable in order to get usability from them. I don't know if I reach the objective in the proper way, but I least I feel more comfortable using my extension.

The extesion will be used in my main project [http://code.google.com/p/tellapic tellapic], but here I've used *SUMI* to show a possible implementation: User Administration.

*PLEASE NOTE*: As I'm writting this, I'll make a big change in the user manager model. Basically, I'll decouple the users model from the view model. That is, I'll separate the basic model (my collection of users) from the model for the view (the `TreeTableModel`) as my model *must* be put appart from everything related to views. The `TreeTableModel` should be the specific class that wraps around or uses the most basi model. It allows me to write a model-view independent model (whatever that means). The next example will be the same, but with a proper written model.


=== What will you get? ===

Well, something like [http://i.imgur.com/OK7Q3.png this]:

[http://i.imgur.com/OK7Q3.png http://i.imgur.com/OK7Q3.png]

I've created a basic interface for gathering system user information. This depends on what OS you are running the software. So, I wrote a `Service` interface and I've only written concrete classes based on Linux OSes.

Anyway, that has nothing to do with the use of the `TellapicTreeTable` extension and its `TellapicNode`s and `TellapicNodeAction`s, so I'll not mention anything about that. Just keep the abstraction :) (thats what an interface is it for though).

=== Where to start? ===

If you have followed the first example, you probably want to be sure that you have something working. But the good news are: SUMI provides a bunch of standards renderers (_still coding those_) and editors (_and these_). For this complex example, you won't need to write any renderer/editor (you _should_ have learned that with the first example).

I have created this _case of use_ supposing each object knows how to create it's properties information. For example, the `SumiUser` abstract class knows how to return its `TellapicNode` based on his properties (or _fields_). This is related with the above note about decoupling the model. The next example, I'll leave this job to the `TellapicTreeTableModel` instead. The model should know about the object it manages. For example, suppose you extend `TellapicTreeTableModel` with `MyPetsModel`. One initial approach will be `MyPetsModel` knowing what `MyPets` objects are. Based on that information, the model will create each `TellapicNode`s and `TellapicNodeAction`s for every `MyPets` it manages. Think about a `FileSystemModel`. The model _knows_ which file system is based on, and how files/directories are managed.

That said, I'll erroneously let `SumiUser` abstract class to implement `TellapicNodeCreatorInterface.getObjectRootNode()` method.

This is the interface that I'm talking about:

{{{
public interface TellapicNodeCreatorInterface {

    /**
     * Gets the root node for this object
     * @return a {code}TellapicNode{/code} that its the root of this object
     */
    public TellapicNode getObjectRootNode();
}
}}}

And the code below shows the _erroneously_ written `SumiUser` class:

{{{
public abstract class SumiUser extends Observable implements TellapicNodeCreatorInterface {

    private ToggleUserVisibilityNodeAction toggleVisibilityAction = new ToggleUserVisibilityNodeAction();
    private UserSelectedStateNodeAction    selectedStateAction    = new UserSelectedStateNodeAction();

    // Some code ...

    /*
     * (non-Javadoc)
     * @see ar.com.tellapic.sumi.treetable.TellapicNodeCreatorInterface#getObjectNodes()
     */
    @Override
    public TellapicNode getObjectRootNode() {
        // Create the root node
        TellapicNode rootNode = new TellapicNode(this, getIcon());
        
        // Create the node for the visible property that will hold
        // the action 'toggleVisibilityAction'
        TellapicNode isVisibleNode = new TellapicNode(
                "Visible",             // the displayed name of the node
                getPropertyIcon(),     // the displayed icon
                toggleVisibilityAction // the 'attached' action (i.e. a column)
                );
        
        // Create the node for the name property. This will hold a default label action.
        TellapicNode nameNode = new TellapicNode(
                "Name",
                getPropertyIcon(),
                new DefaultTellapicNodeActionLabel(
                        name,
                        false // we will not edit this field
                        )
                );
        
        // Create the node for the id property and a default label action.
        TellapicNode idNode = new TellapicNode(
                "Id",
                getPropertyIcon(),
                new DefaultTellapicNodeActionLabel(
                        String.valueOf(userId),
                        false // we will not edit this field
                        )
                );
        
        // Lastly, the selected node with a custom action: 'selectedStateAction'
        TellapicNode isSelectedNode = new TellapicNode(
                "Selected",
                getPropertyIcon(),
                selectedStateAction
                );
        
        // Add the nodes to the root node...
        rootNode.add(isSelectedNode);
        rootNode.add(isVisibleNode);
        rootNode.add(nameNode);
        rootNode.add(idNode);
        
        // Configure nodes...[OPTIONAL AND NOT FULLY TESTED]
        isVisibleNode.setTooltipText("User visibility property");
        isSelectedNode.setTooltipText("User selected property");
        nameNode.setTooltipText("User name property");
        idNode.setTooltipText("User id property");
        
        // Return the root
        return rootNode;
    }
    
    // How will the model know if we are selected?
    // There are better approachs maybe, this is straighforward.
    private class UserSelectedStateNodeAction extends DefaultTellapicNodeActionCheckBox {

        // False == Not editable action, just shows information with a checkbox
        public UserSelectedStateNodeAction() {
            super("", false);
        }
        
        @Override
        public Object getValue() {
            return isSelected();
        }
    }
    
    // We will provide a way to interact with this user visibility property.
    // This is another straightforward example of using @see ar.com.tellapic.gumi.TellapicNodeAction
    private class ToggleUserVisibilityNodeAction extends DefaultTellapicNodeActionCheckBox {
        
        // False == Not editable action, just shows information with a checkbox
        public ToggleUserVisibilityNodeAction() {
            super("", false);
        }
        
        /* (non-Javadoc)
         * @see ar.com.tellapic.gumi.TellapicNodeAction#setValue(java.lang.Object)
         */
        @Override
        public void setValue(Object value) {
            // Avoid halting in vain if for some reason the model is doing something wrong
            // Log to standard output instead
            if (value instanceof Boolean)
                setVisible((Boolean) value);
            else
                System.out.println("[WRN!!] Value "+value+" should be a Boolean instance.");
        }

        /* (non-Javadoc)
         * @see ar.com.tellapic.gumi.TellapicNodeAction#getValue()
         */
        @Override
        public Object getValue() {
            return isVisible();
        }
    }
}
}}}

Ok. This is an abstract class (oh, a _erroneously_ written abstract class). We need to extend this class for our "system users" example. So, I'll extend it and create `SystemSumiUser` _concrete_ class:
